LOLCoffee = {
  KEYWORDS: ['IF U SAY SO', 'IM OUTTA YR', 'QUOSHUNT OF', 'PRODUKT OF', 'BOTH SAEM', 'EITHER OF', 'HOW DUZ I', 'SMALLR OF', 'BIGGR OF', 'CHARZ OF', 'DIFFRINT', 'FOUND YR', 'IM IN YR', 'IS NOW A', 'LENGZ OF', 'BOTH OF', 'DIFF OF', 'I HAS A', 'KTHXBYE', 'ORDZ OF', 'VISIBLE', 'ALL OF', 'ANY OF', 'BUKKIT', 'GIMMEH', 'MOD OF', 'NERFIN', 'NUMBAR', 'NO WAI', 'O RLY?', 'OMGWTF', 'SMOOSH', 'SUM OF', 'WON OF', 'YA RLY', 'MEBBE', 'NUMBR', 'TROOF', 'UPPIN', 'FAIL', 'GTFO', 'INTA', 'MAEK', 'MKAY', 'NOOB', 'PUTZ', 'WILE', 'WTF?', 'YARN', 'HAI', 'ITZ', 'NOT', 'OIC', 'OMG', 'TIL', 'WIN', 'AN', 'AT', 'YR', '!', 'A', 'R'],
  UNARY_OPERATORS: ['NOT', 'LENGZ OF', 'CHARZ OF', 'ORDZ OF'],
  BINARY_OPERATORS: ['SUM OF', 'DIFF OF', 'PRODUKT OF', 'QUOSHUNT OF', 'MOD OF', 'BIGGR OF', 'SMALLR OF', 'BOTH OF', 'EITHER OF', 'WON OF', 'BOTH SAEM', 'DIFFRINT'],
  INFINITARY_OPERATORS: ['ALL OF', 'ANY OF', 'SMOOSH'],
  DEFAULT_VALUES: {
    YARN: '',
    NUMBR: 0,
    NUMBAR: 0,
    TROOF: false,
    NOOB: null
  }
};

/*
A virtual machine for the LOLCoffee compiler. Defines the instructions that can
be generated by the parse tree nodes and a simple machine interface. The machine
supports loading multiple programs, blocking for asynchronous external calls and
single-step execution.

Example usage:
  codegen_context = ...

  input_callback = ->
    $.get 'input.txt', (text) -> 
      machine.resume text

  output_callback = (output) ->
    $('#result')[0].value += output
    machine.resume()

  halt_callback = ->
    console.log 'Mahine halted. Loading new program...'
    # Generate code for a new program using codegen_context.
    machine.run()

  error_callback = (error) ->
    console.assert error instanceof LOLCoffee.MachineError
    console.log error

  machine = new LOLCoffee.Machine codegen_context,
                                  input_callback,
                                  output_callback,
                                  error_callback,
                                  halt_callback
  machine.run()

Provides:
  LOLCoffee.Machine
  LOLCoffee.MachineError
  LOLCoffee.Instructions
*/ 
var Add, All, And, Any, Assign, AssignAtIndex, BoolOperation, Call, Cast, Concat, DeclareFunction, DeclareVariable, Divide, Equal, Frame, FromCharCode, GetIndex, GetLength, Halt, Input, Invert, Jump, JumpIfZero, Machine, MachineError, MathOperation, Max, Min, Modulo, Multiply, Or, Output, PushLiteral, PushSyscallResult, PushVariable, Return, Subtract, ToCharCode, Unequal, Value, Xor;
var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
MachineError = (function() {
  __extends(MachineError, Error);
  function MachineError(message) {
    this.message = message + '.';
  }
  MachineError.prototype.name = 'MachineError';
  return MachineError;
})();
Value = (function() {
  function Value(type, value) {
    this.type = type;
    this.value = value;
  }
  Value.prototype.equal = function(other) {
    var _ref, _ref2;
    if (((_ref = this.type) === 'float' || _ref === 'int') && ((_ref2 = other.type) === 'float' || _ref2 === 'int')) {
      return this.value === other.value;
    } else if (this.type === other.type) {
      return this.value === other.value;
    } else {
      return false;
    }
  };
  Value.prototype.cast = function(to_type, explicit) {
    var result;
    if (explicit == null) {
      explicit = false;
    }
    if (to_type === 'null') {
      throw new MachineError('Cannot cast to NOOB');
    }
    result = null;
    switch (this.type) {
      case 'null':
        if (explicit) {
          if (!(to_type in LOLCoffee.DEFAULT_VALUES)) {
            throw new MachineError('Unknown type: ' + to_type);
          }
          result = LOLCoffee.DEFAULT_VALUES[to_type];
        } else {
          if (to_type !== 'bool') {
            throw new MachineError('Cannot implicitly cast NOOB to ' + to_type);
          }
          result = false;
        }
        break;
      case 'bool':
        result = (function() {
          switch (to_type) {
            case 'bool':
              return this.value;
            case 'int':
            case 'float':
              return Number(this.value);
            case 'string':
              if (this.value) {
                return 'WIN';
              } else {
                return 'FAIL';
              }
              break;
            default:
              throw new MachineError('Unknown type: ' + to_type);
          }
        }).call(this);
        break;
      case 'int':
        result = (function() {
          switch (to_type) {
            case 'bool':
              return this.value !== 0;
            case 'int':
            case 'float':
              return this.value;
            case 'string':
              return String(this.value);
            default:
              throw new MachineError('Unknown type: ' + to_type);
          }
        }).call(this);
        break;
      case 'float':
        result = (function() {
          switch (to_type) {
            case 'bool':
              return this.value !== 0;
            case 'int':
              return Math.floor(this.value);
            case 'float':
              return this.value;
            case 'string':
              return String(this.value);
            default:
              throw new MachineError('Unknown type: ' + to_type);
          }
        }).call(this);
        break;
      case 'string':
        result = (function() {
          switch (to_type) {
            case 'bool':
              return this.value !== '';
            case 'int':
              if (!/^-?\d+$/.test(this.value)) {
                throw new MachineError("Cannot parse NUMBR from '" + this.value + "'");
              }
              return parseInt(this.value, 10);
            case 'float':
              if (!/^-?(\d+(\.\d*)?|\.\d+)$/.test(this.value)) {
                throw new MachineError("Cannot parse NUMBAR from '" + this.value + "'");
              }
              return parseFloat(this.value);
            case 'string':
              return this.value;
            default:
              throw new MachineError('Unknown type: ' + to_type);
          }
        }).call(this);
        break;
      default:
        throw new MachineError('Unknown type: ' + this.type);
    }
    return new Value(to_type, result);
  };
  return Value;
})();
Frame = (function() {
  function Frame(name, instruction_ptr) {
    this.name = name;
    this.instruction_ptr = instruction_ptr;
    this.variables = {};
    this.stack = [];
  }
  return Frame;
})();
Halt = (function() {
  function Halt() {}
  Halt.prototype.exec = function(machine) {
    machine.halted = true;
    return machine.done();
  };
  return Halt;
})();
Jump = (function() {
  function Jump(label) {
    this.label = label;
  }
  Jump.prototype.exec = function(machine) {
    return machine.instruction_ptr = machine.labels[this.label];
  };
  return Jump;
})();
JumpIfZero = (function() {
  function JumpIfZero(label) {
    this.label = label;
  }
  JumpIfZero.prototype.exec = function(machine) {
    if (machine.getStack().pop().value === false) {
      return machine.instruction_ptr = machine.labels[this.label];
    }
  };
  return JumpIfZero;
})();
DeclareFunction = (function() {
  function DeclareFunction(name, label) {
    this.name = name;
    this.label = label;
  }
  DeclareFunction.prototype.exec = function(machine) {
    return machine.functions[this.name] = machine.labels[this.label];
  };
  return DeclareFunction;
})();
DeclareVariable = (function() {
  function DeclareVariable(identifier) {
    this.identifier = identifier;
  }
  DeclareVariable.prototype.exec = function(machine) {
    var top_frame;
    if (this.identifier === 'IT') {
      throw new MachineError('Cannot declare the special variable IT');
    }
    top_frame = machine.frames.slice(-1)[0];
    return top_frame.variables[this.identifier] = new Value('null', null);
  };
  return DeclareVariable;
})();
Assign = (function() {
  function Assign(identifier) {
    this.identifier = identifier;
  }
  Assign.prototype.exec = function(machine) {
    var global_vars, local_vars, value;
    global_vars = machine.frames[0].variables;
    local_vars = machine.frames.slice(-1)[0].variables;
    value = machine.getStack().pop();
    if (this.identifier in local_vars) {
      return local_vars[this.identifier] = value;
    } else if (this.identifier in global_vars) {
      return global_vars[this.identifier] = value;
    } else {
      throw new MachineError('Assignment to undefined variable: ' + this.identifier);
    }
  };
  return Assign;
})();
AssignAtIndex = (function() {
  function AssignAtIndex(identifier) {
    this.identifier = identifier;
  }
  AssignAtIndex.prototype.exec = function(machine) {
    var base, global_vars, index, local_vars, result, scope, value;
    global_vars = machine.frames[0].variables;
    local_vars = machine.frames.slice(-1)[0].variables;
    if (this.identifier in local_vars) {
      scope = local_vars;
    } else if (this.identifier in global_vars) {
      scope = global_vars;
    } else {
      throw new MachineError('Assignment to undefined variable: ' + this.identifier);
    }
    base = scope[this.identifier];
    index = machine.getStack().pop();
    value = machine.getStack().pop();
    if (base.type !== 'string') {
      throw new MachineError('Can only index YARNs, not ' + base.type);
    }
    if (index.type !== 'int') {
      throw new MachineError('Can only index using NUMBRs, not ' + index.type);
    }
    if (index.value >= base.value.length) {
      throw new MachineError("Out of bounds: '" + base.value + "'[" + index.value + "]");
    }
    if (value.type !== 'string' || value.value.length !== 1) {
      throw new MachineError('Can only assign single-character YARNs to YARN ' + 'indices, not ' + value.value);
    }
    base = base.value;
    result = base.slice(0, index.value) + value.value + base.slice(index.value + 1);
    return scope[this.identifier] = new Value('string', result);
  };
  return AssignAtIndex;
})();
Input = (function() {
  function Input() {}
  Input.prototype.exec = function(machine) {
    machine.pause();
    return machine.input();
  };
  return Input;
})();
Output = (function() {
  function Output() {}
  Output.prototype.exec = function(machine) {
    machine.pause();
    return machine.output(machine.getStack().pop().value);
  };
  return Output;
})();
PushSyscallResult = (function() {
  function PushSyscallResult() {}
  PushSyscallResult.prototype.exec = function(machine) {
    var result;
    result = machine.syscall_result;
    result = result ? String(result) : '';
    return machine.getStack().push(new Value('string', result));
  };
  return PushSyscallResult;
})();
PushVariable = (function() {
  function PushVariable(identifier) {
    this.identifier = identifier;
  }
  PushVariable.prototype.exec = function(machine) {
    var global_vars, local_vars, value;
    global_vars = machine.frames[0].variables;
    local_vars = machine.frames.slice(-1)[0].variables;
    if (this.identifier in local_vars) {
      value = local_vars[this.identifier];
    } else if (this.identifier in global_vars) {
      value = global_vars[this.identifier];
    } else {
      throw new MachineError('Reference to undefined variable: ' + this.identifier);
    }
    return machine.getStack().push(value);
  };
  return PushVariable;
})();
GetIndex = (function() {
  function GetIndex() {}
  GetIndex.prototype.exec = function(machine) {
    var base, index;
    base = machine.getStack().pop();
    index = machine.getStack().pop();
    if (base.type !== 'string') {
      throw new MachineError('Can only index YARNs, not ' + base.type);
    }
    if (index.type !== 'int') {
      throw new MachineError('Can only index using NUMBRs, not ' + index.type);
    }
    if (index.value >= base.value.length) {
      throw new MachineError("Out of bounds: '" + base.value + "'[" + index.value + "]");
    }
    return machine.getStack().push(new Value('string', base.value[index.value]));
  };
  return GetIndex;
})();
PushLiteral = (function() {
  function PushLiteral(type, value) {
    this.type = type;
    this.value = value;
  }
  PushLiteral.prototype.exec = function(machine) {
    return machine.getStack().push(new Value(this.type, this.value));
  };
  return PushLiteral;
})();
Cast = (function() {
  function Cast(type, explicit) {
    this.type = type;
    this.explicit = explicit != null ? explicit : false;
  }
  Cast.prototype.exec = function(machine) {
    return machine.getStack().push(machine.getStack().pop().cast(this.type, this.explicit));
  };
  return Cast;
})();
Call = (function() {
  function Call(func_name, args_count) {
    this.func_name = func_name;
    this.args_count = args_count;
  }
  Call.prototype.exec = function(machine) {
    var old_stack, _, _ref;
    old_stack = machine.getStack();
    machine.frames.push(new Frame(this.func_name, machine.instruction_ptr));
    for (_ = 0, _ref = this.args_count; 0 <= _ref ? _ < _ref : _ > _ref; 0 <= _ref ? _++ : _--) {
      machine.getStack().push(old_stack.pop());
    }
    return machine.instruction_ptr = machine.functions[this.func_name];
  };
  return Call;
})();
Return = (function() {
  function Return() {}
  Return.prototype.exec = function(machine) {
    var frame, result;
    result = machine.getStack().pop();
    frame = machine.frames.pop();
    machine.instruction_ptr = frame.instruction_ptr;
    return machine.getStack().push(result);
  };
  return Return;
})();
All = (function() {
  function All(args_count) {
    this.args_count = args_count;
  }
  All.prototype.exec = function(machine) {
    var arg, args, result, _, _i, _len;
    args = (function() {
      var _ref, _results;
      _results = [];
      for (_ = 0, _ref = this.args_count; 0 <= _ref ? _ < _ref : _ > _ref; 0 <= _ref ? _++ : _--) {
        _results.push(machine.getStack().pop().cast('bool').value);
      }
      return _results;
    }).call(this);
    result = true;
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (!arg) {
        result = false;
        break;
      }
    }
    return machine.getStack().push(new Value('bool', result));
  };
  return All;
})();
Any = (function() {
  function Any(args_count) {
    this.args_count = args_count;
  }
  Any.prototype.exec = function(machine) {
    var arg, args, result, _, _i, _len;
    args = (function() {
      var _ref, _results;
      _results = [];
      for (_ = 0, _ref = this.args_count; 0 <= _ref ? _ < _ref : _ > _ref; 0 <= _ref ? _++ : _--) {
        _results.push(machine.getStack().pop().cast('bool').value);
      }
      return _results;
    }).call(this);
    result = false;
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (arg) {
        result = true;
        break;
      }
    }
    return machine.getStack().push(new Value('bool', result));
  };
  return Any;
})();
Concat = (function() {
  function Concat(args_count) {
    this.args_count = args_count;
  }
  Concat.prototype.exec = function(machine) {
    var args, _;
    args = (function() {
      var _ref, _results;
      _results = [];
      for (_ = 0, _ref = this.args_count; 0 <= _ref ? _ < _ref : _ > _ref; 0 <= _ref ? _++ : _--) {
        _results.push(machine.getStack().pop().cast('string').value);
      }
      return _results;
    }).call(this);
    return machine.getStack().push(new Value('string', args.join('')));
  };
  return Concat;
})();
MathOperation = (function() {
  function MathOperation() {}
  MathOperation.prototype.exec = function(machine, operation) {
    var left, result, right, type;
    left = machine.getStack().pop();
    right = machine.getStack().pop();
    type = 'float' === left.type || 'float' === right.type ? 'float' : 'int';
    left = left.cast(type).value;
    right = right.cast(type).value;
    result = operation(left, right);
    if (type === 'int') {
      result = Math.floor(result);
    }
    return machine.getStack().push(new Value(type, result));
  };
  return MathOperation;
})();
Add = (function() {
  __extends(Add, MathOperation);
  function Add() {
    Add.__super__.constructor.apply(this, arguments);
  }
  Add.prototype.exec = function(machine) {
    return Add.__super__.exec.call(this, machine, function(x, y) {
      return x + y;
    });
  };
  return Add;
})();
Subtract = (function() {
  __extends(Subtract, MathOperation);
  function Subtract() {
    Subtract.__super__.constructor.apply(this, arguments);
  }
  Subtract.prototype.exec = function(machine) {
    return Subtract.__super__.exec.call(this, machine, function(x, y) {
      return x - y;
    });
  };
  return Subtract;
})();
Multiply = (function() {
  __extends(Multiply, MathOperation);
  function Multiply() {
    Multiply.__super__.constructor.apply(this, arguments);
  }
  Multiply.prototype.exec = function(machine) {
    return Multiply.__super__.exec.call(this, machine, function(x, y) {
      return x * y;
    });
  };
  return Multiply;
})();
Divide = (function() {
  __extends(Divide, MathOperation);
  function Divide() {
    Divide.__super__.constructor.apply(this, arguments);
  }
  Divide.prototype.exec = function(machine) {
    return Divide.__super__.exec.call(this, machine, function(x, y) {
      return x / y;
    });
  };
  return Divide;
})();
Modulo = (function() {
  __extends(Modulo, MathOperation);
  function Modulo() {
    Modulo.__super__.constructor.apply(this, arguments);
  }
  Modulo.prototype.exec = function(machine) {
    return Modulo.__super__.exec.call(this, machine, function(x, y) {
      return x % y;
    });
  };
  return Modulo;
})();
Max = (function() {
  __extends(Max, MathOperation);
  function Max() {
    Max.__super__.constructor.apply(this, arguments);
  }
  Max.prototype.exec = function(machine) {
    return Max.__super__.exec.call(this, machine, function(x, y) {
      if (x > y) {
        return x;
      } else {
        return y;
      }
    });
  };
  return Max;
})();
Min = (function() {
  __extends(Min, MathOperation);
  function Min() {
    Min.__super__.constructor.apply(this, arguments);
  }
  Min.prototype.exec = function(machine) {
    return Min.__super__.exec.call(this, machine, function(x, y) {
      if (x < y) {
        return x;
      } else {
        return y;
      }
    });
  };
  return Min;
})();
BoolOperation = (function() {
  function BoolOperation() {}
  BoolOperation.prototype.exec = function(machine, operation) {
    var left, right;
    left = machine.getStack().pop().cast('bool').value;
    right = machine.getStack().pop().cast('bool').value;
    return machine.getStack().push(new Value('bool', operation(left, right)));
  };
  return BoolOperation;
})();
And = (function() {
  __extends(And, BoolOperation);
  function And() {
    And.__super__.constructor.apply(this, arguments);
  }
  And.prototype.exec = function(machine) {
    return And.__super__.exec.call(this, machine, function(x, y) {
      return x && y;
    });
  };
  return And;
})();
Or = (function() {
  __extends(Or, BoolOperation);
  function Or() {
    Or.__super__.constructor.apply(this, arguments);
  }
  Or.prototype.exec = function(machine) {
    return Or.__super__.exec.call(this, machine, function(x, y) {
      return x || y;
    });
  };
  return Or;
})();
Xor = (function() {
  __extends(Xor, BoolOperation);
  function Xor() {
    Xor.__super__.constructor.apply(this, arguments);
  }
  Xor.prototype.exec = function(machine) {
    return Xor.__super__.exec.call(this, machine, function(x, y) {
      return x ^ y;
    });
  };
  return Xor;
})();
Equal = (function() {
  function Equal() {}
  Equal.prototype.exec = function(machine) {
    var left, right;
    left = machine.getStack().pop();
    right = machine.getStack().pop();
    return machine.getStack().push(new Value('bool', left.equal(right)));
  };
  return Equal;
})();
Unequal = (function() {
  function Unequal() {}
  Unequal.prototype.exec = function(machine) {
    var left, right;
    left = machine.getStack().pop();
    right = machine.getStack().pop();
    return machine.getStack().push(new Value('bool', !left.equal(right)));
  };
  return Unequal;
})();
Invert = (function() {
  function Invert() {}
  Invert.prototype.exec = function(machine) {
    var operand;
    operand = machine.getStack().pop().cast('bool').value;
    return machine.getStack().push(new Value('bool', !operand));
  };
  return Invert;
})();
GetLength = (function() {
  function GetLength() {}
  GetLength.prototype.exec = function(machine) {
    var operand;
    operand = machine.getStack().pop();
    if (operand.type !== 'string') {
      throw new MachineError('Can only get length of YARNs');
    }
    return machine.getStack().push(new Value('int', operand.value.length));
  };
  return GetLength;
})();
FromCharCode = (function() {
  function FromCharCode() {}
  FromCharCode.prototype.exec = function(machine) {
    var operand, str;
    operand = machine.getStack().pop();
    if (operand.type !== 'int') {
      throw new MachineError('Character codes must be NUMBRs, not ' + operand.type);
    }
    str = String.fromCharCode(operand.value);
    return machine.getStack().push(new Value('string', str));
  };
  return FromCharCode;
})();
ToCharCode = (function() {
  function ToCharCode() {}
  ToCharCode.prototype.exec = function(machine) {
    var operand;
    operand = machine.getStack().pop();
    if (operand.type !== 'string' || !operand.value.length) {
      throw new MachineError('Can only take character code of non-empty ' + ("YARNs, not '" + operand.type + "'"));
    }
    return machine.getStack().push(new Value('int', operand.value.charCodeAt(0)));
  };
  return ToCharCode;
})();
Machine = (function() {
  function Machine(context, input, output, error, done) {
    this.context = context;
    this.input = input;
    this.output = output;
    this.error = error != null ? error : (function() {});
    this.done = done != null ? done : (function() {});
    this.instructions = this.context.instructions;
    this.labels = this.context.labels;
    this.reset();
    this.input = this.input || __bind(function() {
      return this.resume();
    }, this);
    this.output = this.output || __bind(function() {
      return this.resume();
    }, this);
  }
  Machine.prototype.reset = function() {
    this.instruction_ptr = 0;
    this.frames = [new Frame('{MAIN}', 0)];
    this.frames[0].variables.IT = new Value('null', null);
    this.functions = {};
    this.halted = true;
    this.blocked = false;
    return this.syscall_result = null;
  };
  Machine.prototype.step = function() {
    if (this.blocked || this.halted || this.instruction_ptr >= this.instructions.length) {
      throw new MachineError('Cannot execute while blocked, halted or at end');
    }
    try {
      return this.instructions[this.instruction_ptr++].exec(this);
    } catch (e) {
      this.error(e);
      return this.halted = true;
    }
  };
  Machine.prototype.run = function() {
    var _results;
    this.halted = false;
    _results = [];
    while (!(this.blocked || this.halted)) {
      _results.push(this.step());
    }
    return _results;
  };
  Machine.prototype.pause = function() {
    return this.blocked = true;
  };
  Machine.prototype.resume = function(syscall_result) {
    if (syscall_result == null) {
      syscall_result = null;
    }
    this.syscall_result = syscall_result;
    this.blocked = false;
    if (!this.halted) {
      return this.run();
    }
  };
  Machine.prototype.getStack = function() {
    return this.frames[this.frames.length - 1].stack;
  };
  return Machine;
})();
LOLCoffee.Machine = Machine;
LOLCoffee.MachineError = MachineError;
LOLCoffee.Instructions = {
  Halt: Halt,
  PushLiteral: PushLiteral,
  DeclareFunction: DeclareFunction,
  Jump: Jump,
  DeclareVariable: DeclareVariable,
  Assign: Assign,
  AssignAtIndex: AssignAtIndex,
  Return: Return,
  Input: Input,
  PushSyscallResult: PushSyscallResult,
  Output: Output,
  PushVariable: PushVariable,
  GetIndex: GetIndex,
  Cast: Cast,
  JumpIfZero: JumpIfZero,
  Call: Call,
  All: All,
  Any: Any,
  Concat: Concat,
  Add: Add,
  Subtract: Subtract,
  Multiply: Multiply,
  Divide: Divide,
  Modulo: Modulo,
  Max: Max,
  Min: Min,
  And: And,
  Or: Or,
  Xor: Xor,
  Equal: Equal,
  Unequal: Unequal,
  Invert: Invert,
  GetLength: GetLength,
  FromCharCode: FromCharCode,
  ToCharCode: ToCharCode
};

/*
Codegenable parse tree nodes for LOLCODE. The nodes are organized into a
hierarchy rooted at LOLCoffee.AST.Node:
  Node
    Program
    Statement
      FunctionDefinition
      Declaration
      Return
      Input
      Output
      Assignment
      IndexedAssignment
      Break
      Loop
      Conditional
      Switch
      StatementList
      Expression
        IdentifierExpression
        IndexingExpression
        CastExpression
        CallExpression
        UnaryExpression
        BinaryExpression
        InfinitaryExpression
        Literal
          NullLiteral
          BoolLiteral
          IntLiteral
          FloatLiteral
          StringLiteral

Each node has a codegen method that takes a CodeGenContext and emits the
instructions and labels that implement the node. The CodeGenContext keeps track
of the labels and instructions created by the nodes. It can be used to codegen
multiple programs. Each time it is used, the new instructions and labels are
appended to the existing ones. This allows multiple programs to run on the same
VM and share globals, as in the context of a REPL.

Example usage:
  parsed_program_1 = ...
  parsed_program_2 = ...
  codegen_context = new LOLCoffee.CodeGenContext
  try
    parsed_program_1.codegen codegen_context
    # Can now sync the VM to codegen_context and run the first program.
    parsed_program_2.codegen codegen_context
    # Can now sync the VM to codegen_context and run the second program.
  catch error
    console.assert error instanceof LOLCoffee.CodeGenError
    console.log error

Provides:
  LOLCoffee.CodeGenError
  LOLCoffee.CodeGenContext
  LOLCoffee.AST

Requires:
  LOLCoffee.Instructions
*/ 
var Assignment, BinaryExpression, BoolLiteral, Break, CallExpression, CastExpression, CodeGenContext, CodeGenError, Conditional, Declaration, Expression, FloatLiteral, FunctionDefinition, IdentifierExpression, IndexedAssignment, IndexingExpression, InfinitaryExpression, Input, Instructions, IntLiteral, Literal, Loop, Node, NullLiteral, Output, Program, Return, Statement, StatementList, StringLiteral, Switch, UnaryExpression;
var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
};
Instructions = LOLCoffee.Instructions;
CodeGenError = (function() {
  __extends(CodeGenError, Error);
  function CodeGenError(message) {
    this.message = message;
  }
  CodeGenError.prototype.name = 'CodeGenError';
  return CodeGenError;
})();
CodeGenContext = (function() {
  function CodeGenContext() {
    this.instructions = [];
    this.labels = [];
    this._break_stack = [];
  }
  CodeGenContext.prototype.emit = function(instruction) {
    return this.instructions.push(instruction);
  };
  CodeGenContext.prototype.newLabel = function() {
    this.labels.push(null);
    return this.labels.length - 1;
  };
  CodeGenContext.prototype.emitLabel = function(label) {
    if (label >= this.labels.length) {
      throw new CodeGenError("Unknown label (" + label + "). Top: " + this.labels.length);
    }
    return this.labels[label] = this.instructions.length;
  };
  CodeGenContext.prototype.getBreakLabel = function() {
    return this._break_stack[this._break_stack.length - 1];
  };
  CodeGenContext.prototype.popBreakLabel = function() {
    return this._break_stack.pop();
  };
  CodeGenContext.prototype.pushBreakLabel = function(label) {
    return this._break_stack.push(label);
  };
  return CodeGenContext;
})();
Node = (function() {
  function Node() {}
  return Node;
})();
Program = (function() {
  __extends(Program, Node);
  function Program(body) {
    this.body = body;
  }
  Program.prototype.codegen = function(context) {
    this.body.codegen(context);
    return context.emit(new Instructions.Halt);
  };
  return Program;
})();
FunctionDefinition = (function() {
  __extends(FunctionDefinition, Node);
  function FunctionDefinition(name, args, body) {
    this.name = name;
    this.args = args;
    this.body = body;
  }
  FunctionDefinition.prototype.codegen = function(context) {
    var arg, end_label, start_label, _i, _len, _ref;
    start_label = context.newLabel();
    end_label = context.newLabel();
    context.emit(new Instructions.DeclareFunction(this.name, start_label));
    context.emit(new Instructions.Jump(end_label));
    context.emitLabel(start_label);
    this.args.reverse();
    _ref = this.args;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      arg = _ref[_i];
      context.emit(new Instructions.DeclareVariable(arg));
      context.emit(new Instructions.Assign(arg));
    }
    this.body.codegen(context);
    return context.emitLabel(end_label);
  };
  return FunctionDefinition;
})();
Statement = (function() {
  __extends(Statement, Node);
  function Statement() {
    Statement.__super__.constructor.apply(this, arguments);
  }
  return Statement;
})();
Return = (function() {
  __extends(Return, Statement);
  function Return(value) {
    this.value = value;
  }
  Return.prototype.codegen = function(context) {
    this.value.codegen(context);
    return context.emit(new Instructions.Return);
  };
  return Return;
})();
Input = (function() {
  __extends(Input, Statement);
  function Input(identifier) {
    this.identifier = identifier;
  }
  Input.prototype.codegen = function(context) {
    context.emit(new Instructions.Input);
    context.emit(new Instructions.PushSyscallResult);
    return context.emit(new Instructions.Assign(this.identifier));
  };
  return Input;
})();
Output = (function() {
  __extends(Output, Statement);
  function Output(expression) {
    this.expression = expression;
  }
  Output.prototype.codegen = function(context) {
    this.expression.codegen(context);
    return context.emit(new Instructions.Output);
  };
  return Output;
})();
Declaration = (function() {
  __extends(Declaration, Statement);
  function Declaration(identifier) {
    this.identifier = identifier;
  }
  Declaration.prototype.codegen = function(context) {
    return context.emit(new Instructions.DeclareVariable(this.identifier));
  };
  return Declaration;
})();
Assignment = (function() {
  __extends(Assignment, Statement);
  function Assignment(identifier, value) {
    this.identifier = identifier;
    this.value = value;
  }
  Assignment.prototype.codegen = function(context) {
    this.value.codegen(context);
    return context.emit(new Instructions.Assign(this.identifier));
  };
  return Assignment;
})();
IndexedAssignment = (function() {
  __extends(IndexedAssignment, Statement);
  function IndexedAssignment(identifier, index, value) {
    this.identifier = identifier;
    this.index = index;
    this.value = value;
  }
  IndexedAssignment.prototype.codegen = function(context) {
    this.value.codegen(context);
    this.index.codegen(context);
    return context.emit(new Instructions.AssignAtIndex(this.identifier));
  };
  return IndexedAssignment;
})();
Break = (function() {
  __extends(Break, Statement);
  function Break() {}
  Break.prototype.codegen = function(context) {
    return context.emit(new Instructions.Jump(context.getBreakLabel()));
  };
  return Break;
})();
StatementList = (function() {
  __extends(StatementList, Statement);
  function StatementList(statements) {
    this.statements = statements;
  }
  StatementList.prototype.codegen = function(context) {
    var statement, _i, _len, _ref, _results;
    _ref = this.statements;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      statement = _ref[_i];
      _results.push(statement.codegen(context));
    }
    return _results;
  };
  return StatementList;
})();
Conditional = (function() {
  __extends(Conditional, Statement);
  function Conditional(then_body, else_body) {
    this.then_body = then_body;
    this.else_body = else_body;
  }
  Conditional.prototype.codegen = function(context) {
    var else_label, end_label;
    else_label = context.newLabel();
    end_label = context.newLabel();
    context.emit(new Instructions.PushVariable('IT'));
    context.emit(new Instructions.Cast('bool'));
    context.emit(new Instructions.JumpIfZero(else_label));
    this.then_body.codegen(context);
    context.emit(new Instructions.Jump(end_label));
    context.emitLabel(else_label);
    if (this.else_body) {
      this.else_body.codegen(context);
    }
    return context.emitLabel(end_label);
  };
  return Conditional;
})();
Switch = (function() {
  __extends(Switch, Statement);
  function Switch(cases, default_case) {
    this.cases = cases;
    this.default_case = default_case;
  }
  Switch.prototype.codegen = function(context) {
    var body, case_tuple, condition, default_label, end_label, label, _, _i, _j, _k, _len, _len2, _len3, _ref, _ref2, _ref3, _ref4, _ref5;
    _ref = this.cases;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      case_tuple = _ref[_i];
      case_tuple.push(context.newLabel());
    }
    if (this.default_case) {
      default_label = context.newLabel();
    }
    end_label = context.newLabel();
    _ref2 = this.cases;
    for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
      _ref3 = _ref2[_j], condition = _ref3[0], _ = _ref3[1], label = _ref3[2];
      condition.codegen(context);
      context.emit(new Instructions.PushVariable('IT'));
      context.emit(new Instructions.Unequal);
      context.emit(new Instructions.JumpIfZero(label));
    }
    if (this.default_case) {
      context.emit(new Instructions.Jump(default_label));
    }
    context.pushBreakLabel(end_label);
    _ref4 = this.cases;
    for (_k = 0, _len3 = _ref4.length; _k < _len3; _k++) {
      _ref5 = _ref4[_k], _ = _ref5[0], body = _ref5[1], label = _ref5[2];
      context.emitLabel(label);
      body.codegen(context);
    }
    if (this.default_case) {
      context.emitLabel(default_label);
      this.default_case.codegen(context);
    }
    context.popBreakLabel();
    return context.emitLabel(end_label);
  };
  return Switch;
})();
Loop = (function() {
  __extends(Loop, Statement);
  function Loop(step, condition, body) {
    this.step = step;
    this.condition = condition;
    this.body = body;
  }
  Loop.prototype.codegen = function(context) {
    var end_label, start_label;
    start_label = context.newLabel();
    end_label = context.newLabel();
    context.emitLabel(start_label);
    if (this.condition) {
      this.condition.codegen(context);
      context.emit(new Instructions.Cast('bool'));
      context.emit(new Instructions.JumpIfZero(end_label));
    }
    this.body.codegen(context);
    if (this.step) {
      this.step.codegen(context);
    }
    context.emit(new Instructions.Jump(start_label));
    return context.emitLabel(end_label);
  };
  return Loop;
})();
Expression = (function() {
  __extends(Expression, Node);
  function Expression() {
    Expression.__super__.constructor.apply(this, arguments);
  }
  return Expression;
})();
CallExpression = (function() {
  __extends(CallExpression, Expression);
  function CallExpression(func_name, args) {
    this.func_name = func_name;
    this.args = args;
  }
  CallExpression.prototype.codegen = function(context) {
    var arg, _i, _len, _ref;
    _ref = this.args;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      arg = _ref[_i];
      arg.codegen(context);
    }
    return context.emit(new Instructions.Call(this.func_name, this.args.length));
  };
  return CallExpression;
})();
IdentifierExpression = (function() {
  __extends(IdentifierExpression, Expression);
  function IdentifierExpression(identifier) {
    this.identifier = identifier;
  }
  IdentifierExpression.prototype.codegen = function(context) {
    return context.emit(new Instructions.PushVariable(this.identifier));
  };
  return IdentifierExpression;
})();
IndexingExpression = (function() {
  __extends(IndexingExpression, Expression);
  function IndexingExpression(base, index) {
    this.base = base;
    this.index = index;
  }
  IndexingExpression.prototype.codegen = function(context) {
    this.index.codegen(context);
    this.base.codegen(context);
    return context.emit(new Instructions.GetIndex);
  };
  return IndexingExpression;
})();
CastExpression = (function() {
  __extends(CastExpression, Expression);
  function CastExpression(expression, type) {
    this.expression = expression;
    this.type = type;
  }
  CastExpression.prototype.codegen = function(context) {
    var sane_type;
    this.expression.codegen(context);
    sane_type = (function() {
      switch (this.type) {
        case 'NOOB':
          return 'null';
        case 'TROOF':
          return 'bool';
        case 'NUMBR':
          return 'int';
        case 'NUMBAR':
          return 'float';
        case 'YARN':
          return 'string';
      }
    }).call(this);
    return context.emit(new Instructions.Cast(sane_type, true));
  };
  return CastExpression;
})();
InfinitaryExpression = (function() {
  __extends(InfinitaryExpression, Expression);
  function InfinitaryExpression(operator, operands) {
    this.operator = operator;
    this.operands = operands;
  }
  InfinitaryExpression.prototype.codegen = function(context) {
    var op, operand, _i, _len, _ref;
    this.operands.reverse();
    _ref = this.operands;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      operand = _ref[_i];
      operand.codegen(context);
    }
    op = (function() {
      switch (this.operator) {
        case 'ALL OF':
          return new Instructions.All(this.operands.length);
        case 'ANY OF':
          return new Instructions.Any(this.operands.length);
        case 'SMOOSH':
          return new Instructions.Concat(this.operands.length);
        default:
          throw new CodeGenError('Unknown infinitary operator.');
      }
    }).call(this);
    return context.emit(op);
  };
  return InfinitaryExpression;
})();
BinaryExpression = (function() {
  __extends(BinaryExpression, Expression);
  function BinaryExpression(operator, left, right) {
    this.operator = operator;
    this.left = left;
    this.right = right;
  }
  BinaryExpression.prototype.codegen = function(context) {
    var op;
    this.right.codegen(context);
    this.left.codegen(context);
    op = (function() {
      switch (this.operator) {
        case 'SUM OF':
          return new Instructions.Add;
        case 'DIFF OF':
          return new Instructions.Subtract;
        case 'PRODUKT OF':
          return new Instructions.Multiply;
        case 'QUOSHUNT OF':
          return new Instructions.Divide;
        case 'MOD OF':
          return new Instructions.Modulo;
        case 'BIGGR OF':
          return new Instructions.Max;
        case 'SMALLR OF':
          return new Instructions.Min;
        case 'BOTH OF':
          return new Instructions.And;
        case 'EITHER OF':
          return new Instructions.Or;
        case 'WON OF':
          return new Instructions.Xor;
        case 'BOTH SAEM':
          return new Instructions.Equal;
        case 'DIFFRINT':
          return new Instructions.Unequal;
        default:
          throw new CodeGenError('Unknown binary operator.');
      }
    }).call(this);
    return context.emit(op);
  };
  return BinaryExpression;
})();
UnaryExpression = (function() {
  __extends(UnaryExpression, Expression);
  function UnaryExpression(operator, operand) {
    this.operator = operator;
    this.operand = operand;
  }
  UnaryExpression.prototype.codegen = function(context) {
    var op;
    this.operand.codegen(context);
    op = (function() {
      switch (this.operator) {
        case 'NOT':
          return new Instructions.Invert;
        case 'LENGZ OF':
          return new Instructions.GetLength;
        case 'CHARZ OF':
          return new Instructions.FromCharCode;
        case 'ORDZ OF':
          return new Instructions.ToCharCode;
        default:
          throw new CodeGenError('Unknown unary operator.');
      }
    }).call(this);
    return context.emit(op);
  };
  return UnaryExpression;
})();
Literal = (function() {
  __extends(Literal, Expression);
  function Literal() {
    Literal.__super__.constructor.apply(this, arguments);
  }
  return Literal;
})();
NullLiteral = (function() {
  __extends(NullLiteral, Literal);
  function NullLiteral() {
    NullLiteral.__super__.constructor.apply(this, arguments);
  }
  NullLiteral.prototype.codegen = function(context) {
    return context.emit(new Instructions.PushLiteral('null', null));
  };
  return NullLiteral;
})();
BoolLiteral = (function() {
  __extends(BoolLiteral, Literal);
  function BoolLiteral(value) {
    this.value = value;
  }
  BoolLiteral.prototype.codegen = function(context) {
    return context.emit(new Instructions.PushLiteral('bool', this.value));
  };
  return BoolLiteral;
})();
IntLiteral = (function() {
  __extends(IntLiteral, Literal);
  function IntLiteral(value) {
    this.value = value;
  }
  IntLiteral.prototype.codegen = function(context) {
    return context.emit(new Instructions.PushLiteral('int', this.value));
  };
  return IntLiteral;
})();
FloatLiteral = (function() {
  __extends(FloatLiteral, Literal);
  function FloatLiteral(value) {
    this.value = value;
  }
  FloatLiteral.prototype.codegen = function(context) {
    return context.emit(new Instructions.PushLiteral('float', this.value));
  };
  return FloatLiteral;
})();
StringLiteral = (function() {
  __extends(StringLiteral, Literal);
  function StringLiteral(value) {
    this.value = value;
  }
  StringLiteral.prototype.codegen = function(context) {
    return context.emit(new Instructions.PushLiteral('string', this.value));
  };
  return StringLiteral;
})();
LOLCoffee.CodeGenError = CodeGenError;
LOLCoffee.CodeGenContext = CodeGenContext;
LOLCoffee.AST = {
  Node: Node,
  Program: Program,
  Statement: Statement,
  FunctionDefinition: FunctionDefinition,
  Declaration: Declaration,
  Return: Return,
  Input: Input,
  Output: Output,
  Assignment: Assignment,
  IndexedAssignment: IndexedAssignment,
  Break: Break,
  Loop: Loop,
  Conditional: Conditional,
  Switch: Switch,
  StatementList: StatementList,
  Expression: Expression,
  IdentifierExpression: IdentifierExpression,
  IndexingExpression: IndexingExpression,
  CastExpression: CastExpression,
  CallExpression: CallExpression,
  UnaryExpression: UnaryExpression,
  BinaryExpression: BinaryExpression,
  InfinitaryExpression: InfinitaryExpression,
  Literal: Literal,
  NullLiteral: NullLiteral,
  BoolLiteral: BoolLiteral,
  IntLiteral: IntLiteral,
  FloatLiteral: FloatLiteral,
  StringLiteral: StringLiteral
};

/*
A parser for LOLCODE. Takes a list of LOLCODE tokens and produces a parse tree.
Since LOLCODE funciton calls are ambiguous until the function being called is
defined, the Parser keeps track of the arities of all functions defined so far.
This means every time you want to parse a new program that uses previously
defined functions, you will need to provide the last parser's function_arities
to the new one.

In general, you should only need to use parseProgram(). However, similar parse
methods for all other grammar rules are also provided.

Example usage:
  tokenized_program_1 = ...
  tokenized_program_2 = ...
  tokenized_expression = ...
  try
    parser1 = new LOLCoffee.Parser tokenized_program_1
    program_1_ast = parser1.parseProgram()

    parser2 = new LOLCoffee.Parser tokenized_program_2, parser1
    program_2_ast = parser2.parseProgram()

    parser3 = new LOLCoffee.Parser tokenized_expression, parser2
    expression_ast = parser3.parseExpression()
  catch error
    console.assert error instanceof LOLCoffee.ParserError
    console.log error

Provides:
  LOLCoffee.Parser
  LOLCoffee.ParserError

Requires:
  LOLCoffee.AST
*/  var AST, Parser, ParserError;
var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }, __indexOf = Array.prototype.indexOf || function(item) {
  for (var i = 0, l = this.length; i < l; i++) {
    if (this[i] === item) return i;
  }
  return -1;
};
AST = LOLCoffee.AST;
ParserError = (function() {
  __extends(ParserError, Error);
  function ParserError(line, message) {
    this.message = "Line " + line + ": " + message + ".";
  }
  ParserError.prototype.name = 'ParserError';
  return ParserError;
})();
Parser = (function() {
  function Parser(tokens, function_arities) {
    this.tokens = tokens;
    this.function_arities = function_arities != null ? function_arities : {};
    this._scope_depth = 0;
    this._in_function = false;
  }
  Parser.prototype.parseProgram = function() {
    var started_with_hai, statements;
    if (!this.tokens.length) {
      return new AST.Program(new AST.StatementList([]));
    }
    started_with_hai = this._nextIs('keyword', 'HAI');
    if (started_with_hai) {
      this._consume();
      if (!this._nextIs('endline')) {
        this._consume('float', '1.2');
      }
      this._consume();
    }
    statements = (function() {
      var _results;
      _results = [];
      while (this.tokens.length && !this._nextIs('keyword', 'KTHXBYE')) {
        _results.push(this.parseStatement());
      }
      return _results;
    }).call(this);
    if (this._nextIs('keyword', 'KTHXBYE')) {
      if (!started_with_hai) {
        this._error('KTHXBYE is not allowed when HAI is not used');
      }
      this._consume('keyword', 'KTHXBYE');
      this._consume('endline');
    }
    if (this.tokens.length !== 0) {
      this._error('Unexpected input after program end');
    }
    return new AST.Program(new AST.StatementList(statements));
  };
  Parser.prototype.parseFunctionDefinition = function() {
    var args, body, name, statements;
    this._consume('keyword', 'HOW DUZ I');
    name = this._consume('identifier');
    args = this.parseFunctionArgs();
    this._consume('endline');
    this.function_arities[name] = args.length;
    this._in_function = true;
    statements = (function() {
      var _results;
      _results = [];
      while (!this._nextIs('keyword', 'IF U SAY SO')) {
        _results.push(this.parseStatement());
      }
      return _results;
    }).call(this);
    statements.push(new AST.Return(new AST.IdentifierExpression('IT')));
    body = new AST.StatementList(statements);
    this._in_function = false;
    this._consume('keyword', 'IF U SAY SO');
    return new AST.FunctionDefinition(name, args, body);
  };
  Parser.prototype.parseFunctionArgs = function() {
    var args;
    args = [];
    while (this._nextIs('keyword', 'YR')) {
      this._consume();
      args.push(this._consume('identifier'));
      if (this._nextIs('keyword', 'AN')) {
        this._consume();
      } else {
        break;
      }
    }
    return args;
  };
  Parser.prototype.parseStatement = function() {
    var statement;
    if (this._nextIs('keyword', 'IM IN YR')) {
      statement = this.parseLoopStatement();
    } else if (this._nextIs('keyword', 'O RLY?')) {
      statement = this.parseConditionalStatement();
    } else if (this._nextIs('keyword', 'WTF?')) {
      statement = this.parseSwitchStatement();
    } else if (this._nextIs('keyword', 'I HAS A')) {
      statement = this.parseDeclaration();
    } else if (this._nextIs('keyword', 'GIMMEH')) {
      statement = this.parseInputStatement();
    } else if (this._nextIs('keyword', 'VISIBLE')) {
      statement = this.parseOutputStatement();
    } else if (this._nextIs('keyword', 'PUTZ')) {
      statement = this.parseIndexedAssignment();
    } else if (this._nextIs('keyword', 'HOW DUZ I')) {
      if (this._in_function) {
        this._error('Cannot define nested functions');
      }
      statement = this.parseFunctionDefinition();
    } else if (this._nextIs('keyword', 'GTFO')) {
      if (this._scope_depth > 0) {
        statement = new AST.Break;
      } else if (this._in_function) {
        statement = new AST.Return(new AST.NullLiteral);
      } else {
        this._error('GTFO must be inside a loop, switch, or function');
      }
      this._consume();
    } else if (this._nextIs('keyword', 'FOUND YR')) {
      this._consume();
      if (!this._in_function) {
        this._error('FOUND YR must be inside a function');
      }
      statement = new AST.Return(this.parseExpression());
    } else if (this.tokens.length >= 2 && this._nextIs('identifier') && this.tokens[1].is('keyword', 'R')) {
      statement = this.parseAssignment();
    } else if (this.tokens.length >= 2 && this._nextIs('identifier') && this.tokens[1].is('keyword', 'IS NOW A')) {
      statement = this.parseCastStatement();
    } else {
      statement = new AST.Assignment('IT', this.parseExpression());
    }
    this._consume('endline');
    return statement;
  };
  Parser.prototype.parseInputStatement = function() {
    this._consume('keyword', 'GIMMEH');
    return new AST.Input(this._consume('identifier'));
  };
  Parser.prototype.parseDeclaration = function() {
    var assignment, declaration, value, variable;
    this._consume('keyword', 'I HAS A');
    variable = this._consume('identifier');
    declaration = new AST.Declaration(variable);
    if (this._nextIs('keyword', 'ITZ')) {
      this._consume();
      if (this._nextIs('keyword', 'A')) {
        this._consume();
        value = LOLCoffee.DEFAULT_VALUES[this.parseType()];
        assignment = new AST.Assignment(variable, value);
      } else {
        assignment = new AST.Assignment(variable, this.parseExpression());
      }
      return new AST.StatementList([declaration, assignment]);
    } else {
      return declaration;
    }
  };
  Parser.prototype.parseAssignment = function() {
    var variable;
    variable = this._consume('identifier');
    this._consume('keyword', 'R');
    return new AST.Assignment(variable, this.parseExpression());
  };
  Parser.prototype.parseIndexedAssignment = function() {
    var identifier, index, value;
    this._consume('keyword', 'PUTZ');
    value = this.parseExpression();
    this._consume('keyword', 'INTA');
    identifier = this._consume('identifier');
    this._consume('keyword', 'AT');
    index = this.parseExpression();
    return new AST.IndexedAssignment(identifier, index, value);
  };
  Parser.prototype.parseLoopStatement = function() {
    var body, condition, expression, inverted, label, limit, operation, statements, variable, variable_exp;
    this._consume('keyword', 'IM IN YR');
    label = this._consume('identifier');
    operation = variable = condition = null;
    if (!this._nextIs('endline')) {
      if (!(this._nextIs('keyword', 'UPPIN') || this._nextIs('keyword', 'NERFIN') || this._nextIs('identifier'))) {
        this._error('A loop operation must follow the loop label');
      }
      operation = this._consume();
      this._consume('keyword', 'YR');
      variable = this._consume('identifier');
      variable_exp = new AST.IdentifierExpression(variable);
      expression = (function() {
        switch (operation) {
          case 'UPPIN':
            return new AST.BinaryExpression('SUM OF', variable_exp, new AST.IntLiteral(1));
          case 'NERFIN':
            return new AST.BinaryExpression('DIFF OF', variable_exp, new AST.IntLiteral(1));
          default:
            if (this.function_arities[operation] !== 1) {
              this._error('Loop operation must be UPPIN, NERFIN or a unary function');
            }
            return new AST.CallExpression(operation, [variable_exp]);
        }
      }).call(this);
      operation = new AST.Assignment(variable, expression);
      if (!this._nextIs('endline')) {
        if (this._nextIs('keyword', 'WILE')) {
          inverted = false;
        } else if (this._nextIs('keyword', 'TIL')) {
          inverted = true;
        } else {
          this._error('A loop variable must be followed by WILE or TIL');
        }
        this._consume();
        limit = this.parseExpression();
        if (inverted) {
          limit = new AST.UnaryExpression('NOT', limit);
        }
      }
    }
    this._consume('endline');
    this._scope_depth++;
    statements = (function() {
      var _results;
      _results = [];
      while (!this._nextIs('keyword', 'IM OUTTA YR')) {
        _results.push(this.parseStatement());
      }
      return _results;
    }).call(this);
    body = new AST.StatementList(statements);
    this._scope_depth--;
    this._consume('keyword', 'IM OUTTA YR');
    if (label !== this._consume('identifier')) {
      this._error('Mismatched loop label');
    }
    return new AST.Loop(operation, limit, body);
  };
  Parser.prototype.parseConditionalStatement = function() {
    var conditional, else_body, else_statements, elseif_body, elseif_statements, elseif_tuples, expression, isNextBlock, then_body, then_statements, _ref;
    this._consume('keyword', 'O RLY?');
    this._consume('endline');
    this._consume('keyword', 'YA RLY');
    this._consume('endline');
    isNextBlock = __bind(function() {
      return this._nextIs('keyword', 'MEBBE') || this._nextIs('keyword', 'NO WAI') || this._nextIs('keyword', 'OIC');
    }, this);
    then_statements = (function() {
      var _results;
      _results = [];
      while (!isNextBlock()) {
        _results.push(this.parseStatement());
      }
      return _results;
    }).call(this);
    then_body = new AST.StatementList(then_statements);
    elseif_tuples = [];
    while (this._nextIs('keyword', 'MEBBE')) {
      this._consume();
      expression = this.parseExpression();
      this._consume('endline');
      elseif_statements = (function() {
        var _results;
        _results = [];
        while (!isNextBlock()) {
          _results.push(this.parseStatement());
        }
        return _results;
      }).call(this);
      elseif_tuples.push([expression, new AST.StatementList(elseif_statements)]);
    }
    else_statements = [];
    else_body = null;
    if (!this._nextIs('keyword', 'OIC')) {
      this._consume('keyword', 'NO WAI');
      this._consume('endline');
      else_statements = (function() {
        var _results;
        _results = [];
        while (!this._nextIs('keyword', 'OIC')) {
          _results.push(this.parseStatement());
        }
        return _results;
      }).call(this);
      if (else_statements) {
        else_body = new AST.StatementList(else_statements);
      }
    }
    this._consume('keyword', 'OIC');
    while (elseif_tuples.length) {
      _ref = elseif_tuples.pop(), expression = _ref[0], elseif_body = _ref[1];
      expression = new AST.Assignment('IT', expression);
      conditional = new AST.Conditional(elseif_body, else_body);
      else_body = new AST.StatementList([expression, conditional]);
    }
    return new AST.Conditional(then_body, else_body);
  };
  Parser.prototype.parseSwitchStatement = function() {
    var case_literal_line, cases, default_case, literal, statements;
    this._consume('keyword', 'WTF?');
    this._consume('endline');
    cases = [];
    default_case = null;
    this._scope_depth++;
    while (!this._nextIs('keyword', 'OIC')) {
      if (this._nextIs('keyword', 'OMG')) {
        this._consume();
        case_literal_line = this.tokens[0].line;
        literal = this.parseLiteral();
        if (!(literal instanceof AST.Literal)) {
          this._error('OMG value must be a literal', case_literal_line);
        }
        this._consume('endline');
        statements = (function() {
          var _results;
          _results = [];
          while (!(this._nextIs('keyword', 'OMG') || this._nextIs('keyword', 'OMGWTF') || this._nextIs('keyword', 'OIC'))) {
            _results.push(this.parseStatement());
          }
          return _results;
        }).call(this);
        cases.push([literal, new AST.StatementList(statements)]);
      } else if (this._nextIs('keyword', 'OMGWTF')) {
        this._consume();
        this._consume('endline');
        statements = (function() {
          var _results;
          _results = [];
          while (!this._nextIs('keyword', 'OIC')) {
            _results.push(this.parseStatement());
          }
          return _results;
        }).call(this);
        default_case = new AST.StatementList(statements);
      } else {
        this._error('Expected OMG, OMGWTF or OIC');
      }
    }
    this._consume();
    this._scope_depth--;
    return new AST.Switch(cases, default_case);
  };
  Parser.prototype.parseExpression = function() {
    var base, keyword;
    if (this._nextIs('keyword')) {
      keyword = this.tokens[0].text;
      if (keyword === 'MAEK') {
        return this.parseCastExpression();
      } else if (__indexOf.call(LOLCoffee.UNARY_OPERATORS, keyword) >= 0) {
        return this.parseUnaryExpression();
      } else if (__indexOf.call(LOLCoffee.BINARY_OPERATORS, keyword) >= 0) {
        return this.parseBinaryExpression();
      } else if (__indexOf.call(LOLCoffee.INFINITARY_OPERATORS, keyword) >= 0) {
        return this.parseInfinitaryExpression();
      } else if (keyword === 'WIN' || keyword === 'FAIL' || keyword === 'NOOB') {
        return this.parseLiteral();
      } else {
        return this._error('Invalid keyword at start of expression');
      }
    } else if (this._nextIs('identifier')) {
      base = this.tokens[0].text in this.function_arities ? this.parseFunctionCall() : new AST.IdentifierExpression(this._consume());
      if (this._nextIs('keyword', 'AT')) {
        this._consume();
        return new AST.IndexingExpression(base, this.parseExpression());
      } else {
        return base;
      }
    } else {
      return this.parseLiteral();
    }
  };
  Parser.prototype.parseCastExpression = function() {
    var expression;
    this._consume('keyword', 'MAEK');
    expression = this.parseExpression();
    if (this._nextIs('keyword', 'A')) {
      this._consume();
    }
    return new AST.CastExpression(expression, this.parseType());
  };
  Parser.prototype.parseCastStatement = function() {
    var expression, identifier, identifier_expr;
    identifier = this._consume('identifier');
    identifier_expr = new AST.IdentifierExpression(identifier);
    this._consume('keyword', 'IS NOW A');
    expression = new AST.CastExpression(identifier_expr, this.parseType());
    return new AST.Assignment(identifier, expression);
  };
  Parser.prototype.parseType = function() {
    var type;
    type = this._consume('keyword');
    if (!(type in LOLCoffee.DEFAULT_VALUES)) {
      this._error('Unknown type');
    }
    return type;
  };
  Parser.prototype.parseLiteral = function() {
    var token;
    if (this._nextIs('string')) {
      return this._createStringLiteral(this._consume());
    } else if (this._nextIs('int')) {
      return new AST.IntLiteral(parseInt(this._consume(), 10));
    } else if (this._nextIs('float')) {
      return new AST.FloatLiteral(parseFloat(this._consume()));
    } else if (this._nextIs('keyword')) {
      token = this._consume();
      if (token === 'WIN' || token === 'FAIL') {
        return new AST.BoolLiteral(token === 'WIN');
      } else if (token === 'NOOB') {
        return new AST.NullLiteral;
      } else {
        return this._error('Unexpected keyword while parsing literal', token.line);
      }
    } else {
      return this._error('Could not parse literal');
    }
  };
  Parser.prototype.parseFunctionCall = function() {
    var args, func, _;
    func = this._consume('identifier');
    if (!(func in this.function_arities)) {
      this._error('Undefined function: ' + func);
    }
    args = (function() {
      var _ref, _results;
      _results = [];
      for (_ = 0, _ref = this.function_arities[func]; 0 <= _ref ? _ < _ref : _ > _ref; 0 <= _ref ? _++ : _--) {
        _results.push(this.parseExpression());
      }
      return _results;
    }).call(this);
    return new AST.CallExpression(func, args);
  };
  Parser.prototype.parseOutputStatement = function() {
    var args;
    this._consume('keyword', 'VISIBLE');
    args = (function() {
      var _results;
      _results = [];
      while (!(this._nextIs('keyword', '!') || this._nextIs('endline'))) {
        _results.push(this.parseExpression());
      }
      return _results;
    }).call(this);
    if (this._nextIs('keyword', '!')) {
      this._consume();
    } else {
      args.push(new AST.StringLiteral('\n'));
    }
    return new AST.Output(new AST.InfinitaryExpression('SMOOSH', args));
  };
  Parser.prototype.parseUnaryExpression = function() {
    var operator;
    operator = this._consume('keyword');
    if (__indexOf.call(LOLCoffee.UNARY_OPERATORS, operator) < 0) {
      this._error('Unknown unary operator: ' + operator);
    }
    return new AST.UnaryExpression(operator, this.parseExpression());
  };
  Parser.prototype.parseBinaryExpression = function() {
    var left, operator, right;
    operator = this._consume('keyword');
    if (__indexOf.call(LOLCoffee.BINARY_OPERATORS, operator) < 0) {
      this._error('Unknown binary operator: ' + operator);
    }
    left = this.parseExpression();
    if (this._nextIs('keyword', 'AN')) {
      this._consume();
    }
    right = this.parseExpression();
    return new AST.BinaryExpression(operator, left, right);
  };
  Parser.prototype.parseInfinitaryExpression = function() {
    var args, operator;
    operator = this._consume('keyword');
    if (__indexOf.call(LOLCoffee.INFINITARY_OPERATORS, operator) < 0) {
      this._error('Unknown infinitary operator: ' + operator);
    }
    args = (function() {
      var _results;
      _results = [];
      while (!(this._nextIs('keyword', 'MKAY') || this._nextIs('endline'))) {
        if (this._nextIs('keyword', 'AN')) {
          this._consume();
        }
        _results.push(this.parseExpression());
      }
      return _results;
    }).call(this);
    if (this._nextIs('keyword', 'MKAY')) {
      this._consume();
    }
    return new AST.InfinitaryExpression(operator, args);
  };
  Parser.prototype._createStringLiteral = function(str) {
    var buffer, chr, hex, index, parts, variable, _len;
    if (!/^".*"$/.test(str)) {
      this._error('Invalid string literal: ' + str);
    }
    str = str.slice(1, -1);
    parts = [];
    buffer = [];
    for (index = 0, _len = str.length; index < _len; index++) {
      chr = str[index];
      if (chr === ':') {
        chr = str[++index];
        switch (chr) {
          case ')':
            buffer.push('\n');
            break;
          case '>':
            buffer.push('\t');
            break;
          case 'o':
            buffer.push('\g');
            break;
          case '"':
            buffer.push('"');
            break;
          case ':':
            buffer.push(':');
            break;
          case '(':
            hex = str.slice(index).match(/\(([\da-fA-F]+)\)/);
            index += hex[0].length - 1;
            buffer.push(String.fromCharCode(parseInt(hex[1], 16)));
            break;
          case '{':
            variable = str.slice(index).match(/\{([a-zA-Z]\w*)\}/);
            index += variable[0].length - 1;
            if (buffer.length) {
              parts.push(new AST.StringLiteral(buffer.join('')));
            }
            parts.push(new AST.IdentifierExpression(variable[1]));
            buffer = [];
            break;
          case '[':
            this._error('Unicode name embedding not implemented yet: ' + str);
        }
      } else {
        buffer.push(chr);
      }
    }
    if (parts.length) {
      if (buffer.length) {
        parts.push(new AST.StringLiteral(buffer.join('')));
      }
      return new AST.InfinitaryExpression('SMOOSH', parts);
    } else {
      return new AST.StringLiteral(buffer.join(''));
    }
  };
  Parser.prototype._consume = function(type, text) {
    var expected, got, line, message;
    if (!((type != null) || (text != null))) {
      return this.tokens.shift().text;
    }
    if (this._nextIs(type, text)) {
      return this._consume();
    } else {
      expected = text != null ? "" + type + "('" + (text || '') + "')" : type;
      if (this.tokens.length === 0) {
        line = '(last)';
        got = '(end of input)';
      } else {
        line = this.tokens[0].line;
        got = "" + this.tokens[0].type + "(" + this.tokens[0].text + ")";
      }
      message = "Expected: " + expected + "; Got: " + got;
      throw new ParserError(line, message);
    }
  };
  Parser.prototype._nextIs = function(type, text) {
    return this.tokens.length && this.tokens[0].is(type, text);
  };
  Parser.prototype._error = function(message, line) {
    if (line) {
      message += ", near " + this.tokens[0].type + ":'" + this.tokens[0].text + "'";
    } else {
      line = this.tokens.length ? this.tokens[0].line : line = '(last)';
    }
    throw new ParserError(line, message);
  };
  return Parser;
})();
LOLCoffee.Parser = Parser;
LOLCoffee.ParserError = ParserError;

/*
A tokenizer for LOLCODE. Splits a LOLCODE source code string into a list of
tokens. Comments are automatically stripped. Line continuation using ellipses
and soft statement terminators using commas are also taken into account.
Multi-word keywords are captured is separated by any inline whitespace. The
produced tokens are tagged with their physical line numbers for error reporting.

The resulting tokens can be of the following types:
  keyword: "HAI", "YA RLY", ...
  identifier: "X3", "First_Counter", ...
  int literals: 123, -456, 0, ..
  float literals: 1.2, 3., .4, -6.2, ...
  string literals: "a::b:(3F)c:{counter}d:[foo]efg", ...

Example usage:
  tokenizer = new LOLCoffee.Tokenizer source_text
  try
    tokens = tokenizer.tokenize()
  catch error
    console.assert error instanceof LOLCoffee.TokenizerError
    console.log error

Provides:
  LOLCoffee.Tokenizer
  LOLCoffee.TokenizerError
*/  var COMMENT_REGEX, FLOAT_REGEX, IDENTIFIER_REGEX, INLINE_SPACE_REGEX, INT_REGEX, KEYWORDS, KEYWORD_REGEX, LINE_CONTINUATION_REGEX, MULTILINE_COMMENT_REGEX, STATEMENT_END_REGEX, STRING_REGEX, Token, Tokenizer, TokenizerError, word;
var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}, __indexOf = Array.prototype.indexOf || function(item) {
  for (var i = 0, l = this.length; i < l; i++) {
    if (this[i] === item) return i;
  }
  return -1;
};
INT_REGEX = /^-?\d+/;
FLOAT_REGEX = /^-?(\d+\.\d*|\.\d+)/;
IDENTIFIER_REGEX = /^[a-zA-Z]\w*/;
MULTILINE_COMMENT_REGEX = /^OBTW\b[^]*?\bTLDR\b/;
COMMENT_REGEX = /^BTW\b.*/;
LINE_CONTINUATION_REGEX = /^(\u2026|\.\.\.)[ \t\v]*(\r\n|\r|\n)/;
STATEMENT_END_REGEX = /^(\r\n|\r|\n|,)/;
INLINE_SPACE_REGEX = /^[ \t\v]+/;
STRING_REGEX = /^"(?::(?:[)>o":]|\([\dA-Fa-f]+\)|\{[A-Za-z]\w*\}|\[[^\[\]]+\])|[^":])*"/;
KEYWORDS = (function() {
  var _i, _len, _ref, _results;
  _ref = LOLCoffee.KEYWORDS;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    word = _ref[_i];
    _results.push(word.replace(/\?/g, '\\?').replace(/\s/g, '[ \\t\\v]+'));
  }
  return _results;
})();
KEYWORD_REGEX = new RegExp("^(" + (KEYWORDS.join('|')) + ")(?=$|\\b|\\W)");
TokenizerError = (function() {
  __extends(TokenizerError, Error);
  function TokenizerError(line, message) {
    this.message = "Line " + line + ": " + message + ".";
  }
  TokenizerError.prototype.name = 'TokenizerError';
  return TokenizerError;
})();
Token = (function() {
  function Token(line, type, text) {
    this.line = line;
    this.type = type;
    this.text = text != null ? text : '';
    if (__indexOf.call(Token.prototype.TYPES, type) < 0) {
      throw new TokenizerError(line, 'Invalid token type: ' + type);
    }
  }
  Token.prototype.is = function(type, text) {
    return this.type === type && (text === void 0 || this.text === text);
  };
  Token.prototype.TYPES = ['endline', 'keyword', 'identifier', 'int', 'float', 'string'];
  return Token;
})();
Tokenizer = (function() {
  function Tokenizer(text) {
    this.text = text;
    this.tokens = [];
    this.line = [];
    this.line_index = 1;
  }
  Tokenizer.prototype.tokenize = function() {
    var line_breaks, match, snippet;
    while (this.text) {
      if (match = this.text.match(INLINE_SPACE_REGEX)) {} else if (match = this.text.match(LINE_CONTINUATION_REGEX)) {
        if (STATEMENT_END_REGEX.test(this.text.slice(match[0].length))) {
          this._error('Cannot have an empty line after line continuation');
        }
      } else if (match = this.text.match(STATEMENT_END_REGEX)) {
        this._flushLine();
      } else if (match = this.text.match(COMMENT_REGEX)) {} else if (match = this.text.match(MULTILINE_COMMENT_REGEX)) {
        if (this.line.length) {
          this._error('Multiline comments must start on a new line');
        }
      } else if (match = this.text.match(KEYWORD_REGEX)) {
        this._emit('keyword', match[0].replace(/\s+/g, ' '));
      } else if (match = this.text.match(IDENTIFIER_REGEX)) {
        this._emit('identifier', match[0]);
      } else if (match = this.text.match(FLOAT_REGEX)) {
        this._emit('float', match[0]);
      } else if (match = this.text.match(INT_REGEX)) {
        this._emit('int', match[0]);
      } else if (match = this.text.match(STRING_REGEX)) {
        this._emit('string', match[0]);
      } else {
        snippet = this.text.match(/^.*/)[0];
        this._error('Unrecognized sequence at: ' + snippet);
      }
      line_breaks = match[0].match(/\r\n|\r|\n/g);
      if (line_breaks) {
        this.line_index += line_breaks.length;
      }
      this.text = this.text.slice(match[0].length);
    }
    this._flushLine();
    return this.tokens;
  };
  Tokenizer.prototype._flushLine = function() {
    if (this.line.length) {
      this.tokens = this.tokens.concat(this.line);
      this.tokens.push(new Token(this.line_index, 'endline'));
    }
    return this.line = [];
  };
  Tokenizer.prototype._emit = function(type, value) {
    return this.line.push(new Token(this.line_index, type, value));
  };
  Tokenizer.prototype._error = function(message) {
    throw new TokenizerError(this.line_index, message);
  };
  return Tokenizer;
})();
LOLCoffee.Tokenizer = Tokenizer;
LOLCoffee.TokenizerError = TokenizerError;

module.exports = LOLCoffee;