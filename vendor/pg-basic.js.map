{"version":3,"sources":["node_modules/context-eval/lib/context-browser.js","functions.js","tokenizer.js","nodes.js","expr.js","parser.js","basic.js"],"names":["Functions","ABS","n","Math","abs","COS","cos","SIN","sin","TAN","tan","EXP","exp","INT","floor","FLOOR","ROUND","round","ATN","atan","LOG","log","SGN","SQR","sqrt","VAL","str","parseFloat","isNaN","RND","f","random","ceil","ASC","charCodeAt","LEFT","slice","MID","start","len","substr","RIGHT","CHR","String","fromCharCode","STR","LEN","length","SPC","repeat","COLOR","Error","GETCHAR","UPPERCASE","toUpperCase","LOWERCASE","toLowerCase","aliases","LEFT$","ATAN","CHR$","MID$","RIGHT$","RAND","TAB","a","module","exports","require","Token","type","lexeme","eof","KEYWORDS","CONSTANTS","LINE","QUOTE","KEY","RegExp","join","FUN","Object","keys","CONST","VAR","NUM","OP","LOGIC","LINEMOD","Tokenizer","stmnt","options","tokens","index","tokenized","debug","line","t","tokenize","assertTokenized","expr","expressionTypes","includes","peek","push","next","linem","match","parseInt","eaten","eatKeyword","eatQuote","eatLogic","eatFunction","eatConstant","eatVariable","eatNumber","eatOperation","eatLineMod","console","tokense","m","keyword","fun","variable","num","Node","lineno","ret","forEach","k","truth","message","Variable","name","subscript","array","REM","comment","PRINT","linemod","newline","context","value","evaluate","print","GOTO","targetno","assert","goto","LET","sub","setArray","set","PAUSE","pause","INPUT","prompt","halt","input","execute","FOR","left","right","step","max","increment","loopStart","NEXT","loopJump","PLOT","x","y","color","plot","END","end","IF","condition","then","elze","run","other","GOSUB","gosub","RETURN","return","ARRAY","CLS","clearAll","CLT","clearConsole","CLC","clearGraphics","exprToJS","jsExpr","shift","Parser","tokenizer","getLineNo","p","parse","top","assertType","expectExpr","acceptLineMod","expectVariable","expectOperation","expectComment","expectLineMod","frm","expectKeyword","to","acceptKeyword","cond","op","acceptSubscript","stopOnComma","brackets","token","expected","Context","Basic","debugLevel","display","constants","PI","LEVEL","__pgb","variables","program","loops","stack","jumped","level","seen","split","filter","l","trim","map","parseLine","sort","b","ended","getNextLine","delay","setTimeout","halted","find","indexOf","getCurLine","node","toJSON","code","e","error","vari","bind","getChar","constant","hasOwnProperty","millis","loop","pop","assertDisplay","s","write","toString","clear","callback"],"mappings":"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","file":"basic.js","sourceRoot":"..","sourcesContent":["function Context(sandbox, parentElement) {\n  this.iframe = document.createElement('iframe');\n  this.iframe.style.display = 'none';\n  parentElement = parentElement || document.body;\n  parentElement.appendChild(this.iframe);\n  var win = this.iframe.contentWindow;\n  if (sandbox) {\n    this.extend(sandbox);\n  }\n}\n\nContext.prototype.evaluate = function (code) {\n  return this.iframe.contentWindow.eval(code);\n};\n\nContext.prototype.destroy = function () {\n  if (this.iframe) {\n    this.iframe.parentNode.removeChild(this.iframe);\n    this.iframe = null;\n  }\n};\n\nContext.prototype.getGlobal = function () {\n  return this.iframe.contentWindow;\n};\n\nContext.prototype.extend = function (sandbox) {\n  var global = this.getGlobal();\n  Object.keys(sandbox).forEach(function (key) {\n    global[key] = sandbox[key];\n  });\n};\n\nmodule.exports = Context;\n","const Functions = {\n  // Math:\n  ABS(n) {\n    return Math.abs(n);\n  },\n\n  COS(n) {\n    return Math.cos(n);\n  },\n\n  SIN(n) {\n    return Math.sin(n);\n  },\n\n  TAN(n) {\n    return Math.tan(n);\n  },\n\n  EXP(n) {\n    return Math.exp(n);\n  },\n\n  INT(n) {\n    return Math.floor(n);\n  },\n\n  FLOOR(n) {\n    return Math.floor(n);\n  },\n\n  ROUND(n) {\n    return Math.round(n);\n  },\n\n  ATN(n) {\n    return Math.atan(n);\n  },\n\n  LOG(n) {\n    return Math.log(n);\n  },\n\n  SGN(n) {\n    if (n === 0) return 0;\n    if (n < 0) return -1;\n    return 1;\n  },\n\n  SQR(n) {\n    return Math.sqrt(n);\n  },\n\n  VAL(str) {\n    const n = parseFloat(str);\n    if (isNaN(n)) return 0;\n    return n;\n  },\n\n  RND(f = 0) {\n    if (f === 0) {\n      return Math.random();\n    }\n    return Math.ceil(Math.random() * f);    \n  },\n\n  // Strings:\n  ASC(str) {\n    return str.charCodeAt(0);\n  },\n\n  LEFT(str, n) {\n    return str.slice(0, n);\n  },\n\n  MID(str, start, len) {\n    // len is optional\n    return str.substr(start, len);\n  },\n\n  RIGHT(str, n) {\n    return str.slice(n * -1);\n  },\n\n  CHR(n) {\n    return String.fromCharCode(n);\n  },\n\n  STR(n) {\n    return String.fromCharCode(n);\n  },\n\n  LEN(str) {\n    return str.length;\n  },\n\n  SPC(n) {\n    return ' '.repeat(n);\n  },\n\n  // Display stubs\n  COLOR() {\n    // This is just a stub. This gets injected.\n    throw new Error('Unimplemented');\n  },\n\n  GETCHAR() {\n    // This is just a stub. This gets injected.\n    throw new Error('Unimplemented');\n  },\n\n  UPPERCASE(str) {\n    return str.toUpperCase();\n  },\n\n  LOWERCASE(str) {\n    return str.toLowerCase();\n  },\n};\n\nconst aliases = {\n  LEFT$: 'LEFT',\n  ATAN: 'ATN',\n  CHR$: 'CHR',\n  MID$: 'MID',\n  RIGHT$: 'RIGHT',\n  RAND: 'RND',\n\n  // Technically TAB should be relative to the current cursor position\n  // but that's too hard to implement now.\n  TAB: 'SPC',\n};\n\nfor (const a in aliases) {\n  Functions[a] = Functions[aliases[a]];\n}\n\nmodule.exports = Functions;","const Functions = require('./functions');\n\nclass Token {\n  constructor(type, lexeme) {\n    this.type = type;\n    this.lexeme = lexeme;\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      lexeme: this.lexeme,\n    };\n  }\n}\n\nconst eof = new Token('eof', '');\n\nconst KEYWORDS = [\n  'IF',\n  'THEN',\n  'ELSE',\n  'FOR',\n  'ON',\n  'TO',\n  'STEP',\n  'GOTO',\n  'GOSUB',\n  'RETURN',\n  'NEXT',\n  'INPUT',\n  'LET',\n  'CLC',\n  'CLT',\n  'CLS',\n  'END',\n  'PRINT',\n  'PLOT',\n  'DRAW',\n  'UNDRAW',\n  'ARRAY',\n  'DIM',\n  'DATA',\n  'READ',\n  'REM',\n  'PAUSE',\n  'STOP',\n];\n\nconst CONSTANTS = [\n  'LEVEL',\n  'PI',\n];\n\nconst LINE = /^\\s*(\\d+)\\s*/;\nconst QUOTE = /^\"((\\\\.|[^\"\\\\])*)\"\\s*/;\nconst KEY = new RegExp('^(' + KEYWORDS.join('|') + ')\\\\s*', 'i');\nconst FUN = new RegExp('^(' + Object.keys(Functions).join('|') + ')\\\\s*', 'i');\nconst CONST = new RegExp('^(' + CONSTANTS.join('|') + ')\\\\s*', 'i');\nconst VAR = /^([a-z][0-9]*)\\$?\\s*/i;\nconst NUM = /^(\\d+(\\.\\d+)?)\\s*/i;\nconst OP = /^(<>|>=|<=|[,\\+\\-\\*\\/%=<>\\(\\)\\]\\[])\\s*/i;\nconst LOGIC = /^(AND|OR)\\s*/i;\nconst LINEMOD = /^(;)\\s*/i;\n\nclass Tokenizer {\n  static get expressionTypes() {\n    return [\n      'string',\n      'function',\n      'operation',\n      'number',\n      'variable',\n      'logic',\n      'constant',\n    ];\n  }\n\n  static get eof() {\n    return eof;\n  }\n\n  static tokenizeLine(line, debug) {\n    const t = new Tokenizer(line, { debug: debug });\n    t.tokenize();\n    return t.tokens;\n  }\n\n  constructor(stmnt, options = {}) {\n    this.stmnt = stmnt;\n    this.tokens = [];\n    this.index = 0;\n    this.tokenized = false;\n    this.debug = options.debug || false;\n  }\n\n  assertTokenized() {\n    if (!this.tokenized) {\n      throw new Error('call tokenize first');\n    }\n  }\n\n  peek(n = 0) {\n    this.assertTokenized();\n\n    if (this.index >= this.tokens.length) return eof;\n\n    return this.tokens[this.index + n];\n  }\n\n  next() {\n    this.assertTokenized();\n\n    if (this.index >= this.tokens.length) return eof;\n\n    return this.tokens[this.index++];\n  }\n\n  nextExpr() {\n    this.assertTokenized();\n\n    const expr = [];\n    while (this.index !== this.tokens.length) {\n      if (!Tokenizer.expressionTypes.includes(this.peek().type)) {\n        break;\n      }\n\n      expr.push(this.next());\n    }\n\n    return expr;\n  }\n\n  tokenize() {\n    const linem = this.stmnt.match(LINE);\n\n    if (!linem) {\n      throw new Error(\"Expected line number\");\n    }\n\n    // First token is always line number.\n    this.tokens.push(new Token('lineno', parseInt(linem[1])));\n\n    this.stmnt = this.stmnt.slice(linem[0].length);\n\n    while (this.stmnt.length) {\n      const eaten = this.eatKeyword() ||\n        this.eatQuote() ||\n        this.eatLogic() ||\n        this.eatFunction() ||\n        this.eatConstant() ||\n        this.eatVariable() ||\n        this.eatNumber() ||\n        this.eatOperation() ||\n        this.eatLineMod();\n\n\n      if (!eaten) {\n        if (this.debug) {\n          console.log(\"tokens\", this.tokense);\n        }\n\n        throw new Error('Invalid syntax near: `' + this.stmnt + `'`);\n      }\n\n      this.stmnt = this.stmnt.slice(eaten.length);\n    }\n\n    this.tokenized = true;\n  }\n\n  eatLogic() {\n    const m = this.stmnt.match(LOGIC);\n    if (m && m[0]) {\n      const keyword = m[1].toUpperCase();\n      this.tokens.push(new Token('logic', keyword));\n      return m[0];\n    }\n    return null;\n  }\n\n  eatKeyword() {\n    const m = this.stmnt.match(KEY);\n    if (m && m[0]) {\n      const keyword = m[1].toUpperCase();\n      this.tokens.push(new Token('keyword', keyword));\n\n      // If the keyword is a comment then eat it up.\n      if (keyword === 'REM') {\n        this.tokens.push(new Token('comment', this.stmnt.slice(m[0].length)));\n        return this.stmnt;\n      }\n\n      return m[0];\n    }\n    return null;\n  }\n\n  eatFunction() {\n    const m = this.stmnt.match(FUN);\n    if (m && m[0]) {\n      const fun = m[1].toUpperCase();\n      this.tokens.push(new Token('function', fun));\n      return m[0];\n    }\n    return null;\n  }\n\n  eatConstant() {\n    const m = this.stmnt.match(CONST);\n    if (m && m[0]) {\n      const fun = m[1].toUpperCase();\n      this.tokens.push(new Token('constant', fun));\n      return m[0];\n    }\n    return null;\n  }\n\n  eatVariable() {\n    const m = this.stmnt.match(VAR);\n    if (m && m[0]) {\n      const variable = m[1].toUpperCase();\n      this.tokens.push(new Token('variable', variable));\n      return m[0];\n    }\n    return null;\n  }\n\n  eatNumber() {\n    const m = this.stmnt.match(NUM);\n    if (m && m[0]) {\n      const num = parseFloat(m[1], 10);\n      if (isNaN(num)) {\n        throw new Error('Error parsing number:' + m[1]);\n      }\n      this.tokens.push(new Token('number', num));\n      return m[0];\n    }\n    return null;\n  }\n\n  eatOperation() {\n    const m = this.stmnt.match(OP);\n    if (m && m[0]) {\n      this.tokens.push(new Token('operation', m[1]));\n      return m[0];\n    }\n    return null;\n  }\n\n  eatQuote() {\n    const m = this.stmnt.match(QUOTE);\n    if (m && m[0]) {\n      this.tokens.push(new Token('string', `\"${m[1]}\"`));\n      return m[0];\n    }\n    return null;\n  }\n\n  eatLineMod() {\n    const m = this.stmnt.match(LINEMOD);\n    if (m && m[0]) {\n      this.tokens.push(new Token('linemod', `\"${m[1]}\"`));\n      return m[0];\n    }\n    return null;\n  }\n}\n\nmodule.exports = Tokenizer;","class Node {\n  constructor(lineno, type) {\n    this.lineno = lineno;\n    this.type = type;\n  }\n\n  toJSON() {\n    const ret = {};\n    Object.keys(this).forEach(k => {\n      ret[k] = this[k];\n    });\n    return ret;\n  }\n\n  assert(truth, message) {\n    if (!truth) {\n      // Todo custom error type\n      throw new Error(`Line ${this.lineno}: ${message}`);\n    }\n  }\n}\n\nclass Variable extends Node {\n  constructor(lineno, name, subscript) {\n    super(lineno, 'variable');\n    this.name = name;\n    if (subscript == null) {\n      this.array = false;\n    } else {\n      this.array = true;\n      this.subscript = subscript;\n    }\n  }\n}\n\nclass REM extends Node {\n  constructor(lineno, comment) {\n    super(lineno, 'REM');\n    this.comment = comment;\n  }\n\n  run() {\n    // noop\n  }\n}\n\nclass PRINT extends Node {\n  constructor(lineno, expr, linemod) {\n    super(lineno, 'PRINT');\n    this.expr = expr;\n    this.newline = !linemod;\n  }\n\n  run(context) {\n    const value = context.evaluate(this.expr);\n    context.print(value);\n\n    if (this.newline) {\n      context.print(\"\\n\");\n    }\n  }\n}\n\nclass GOTO extends Node {\n  constructor(lineno, expr) {\n    super(lineno, 'GOTO');\n    this.expr = expr;\n  }\n\n  run(context) {\n    const targetno = context.evaluate(this.expr);\n    this.assert(typeof targetno === 'number', 'Expected GOTO `expr` to evaluate to a number');\n\n    context.goto(targetno);\n  }\n}\n\nclass LET extends Node {\n  constructor(lineno, variable, expr) {\n    super(lineno, 'LET');\n    this.variable = variable;\n    this.expr = expr;\n  }\n\n  run(context) {\n    const value = context.evaluate(this.expr);\n\n    if (this.variable.array) {\n      const sub = context.evaluate(this.variable.subscript)\n      context.setArray(this.variable.name, sub, value);\n    } else {\n      context.set(this.variable.name, value);\n    }\n  }\n}\n\nclass PAUSE extends Node {\n  constructor(lineno, expr) {\n    super(lineno, 'PAUSE');\n    this.expr = expr;\n  }\n\n  run(context) {\n    const value = context.evaluate(this.expr);\n\n    if (typeof value !== 'number') {\n      throw new Error('Expected pause value to be a number');\n    }\n\n    context.pause(value);\n  }\n}\n\nclass INPUT extends Node {\n  constructor(lineno, expr, variable) {\n    super(lineno, 'INPUT');\n    this.expr = expr;\n    this.variable = variable;\n  }\n\n  run(context) {\n    const prompt = context.evaluate(this.expr);\n\n    context.print(prompt);\n\n    // Yield.\n    context.halt();\n    context.input((value) => {\n      if (this.variable.array) {\n        const sub = context.evaluate(this.variable.subscript);\n        context.setArray(this.variable.name, sub, value);\n      } else {\n        context.set(this.variable.name, value);\n      }\n      \n      // Resume.\n      context.execute();\n    });\n  }\n}\n\nclass FOR extends Node {\n  constructor(lineno, variable, left, right, step) {\n    super(lineno, 'FOR');\n    this.lineno = lineno;\n    this.variable = variable;\n    this.left = left;\n    this.right = right;\n    this.step = step;\n  }\n\n  run(context) {\n    const value = context.evaluate(this.left);\n    const max = context.evaluate(this.right);\n    const increment = this.step ? context.evaluate(this.step) : 1;\n\n    if (this.variable.array) {\n      throw new Error('Cannot use variables in for');\n    }\n\n    context.loopStart({\n      variable: this.variable.name,\n      value,\n      max,\n      increment,\n    });\n  }\n}\n\nclass NEXT extends Node {\n  constructor(lineno, variable) {\n    super(lineno, 'NEXT');\n    this.variable = variable;\n  }\n\n  run(context) {\n    context.loopJump(this.variable.name);\n  }\n}\n\nclass PLOT extends Node {\n  constructor(lineno, x, y, color = \"black\") {\n    super(lineno, 'PLOT');\n    this.x = x;\n    this.y = y;\n    this.color = color;\n  }\n\n  run(context) {    \n    context.plot(context.evaluate(this.x), context.evaluate(this.y), context.evaluate(this.color));\n  }\n}\n\nclass END extends Node {\n  run(context) {\n    context.end();\n  }\n}\n\nclass IF extends Node {\n  constructor(lineno, condition, then, elze) {\n    super(lineno, 'IF');\n    this.condition = condition;\n    this.then = then;\n    this.elze = elze;\n  }\n\n  run(context) {\n    if (context.evaluate(this.condition)) {\n      this.then.run(context);\n    } else if (this.other) {\n      this.elze.run(context);\n    }\n  }\n}\n\nclass GOSUB extends Node {\n  constructor(lineno, expr) {\n    super(lineno, 'GOSUB');\n    this.expr = expr;\n  }\n\n  run(context) {\n    const lineno = context.evaluate(this.expr);\n    if (typeof lineno !== 'number') {\n      throw new Error('Expected GOSUB argument to be a number');\n    }\n\n    context.gosub(lineno);\n  }\n}\n\nclass RETURN extends Node {\n  run(context) {\n    context.return();\n  }\n}\n\nclass ARRAY extends Node {\n  constructor(lineno, variable) {\n    super(lineno, 'ARRAY');\n    this.variable = variable;\n  }\n\n  run(context) {\n    context.array(this.variable.name);\n  }\n}\n\nclass CLS extends Node {\n  run(context) {\n    context.clearAll();\n  }\n}\n\nclass CLT extends Node {\n  run(context) {\n    context.clearConsole();\n  }\n}\n\nclass CLC extends Node {\n  run(context) {\n    context.clearGraphics();\n  }\n}\n\nmodule.exports = {\n  Node,\n  PRINT,\n  GOTO,\n  LET,\n  REM,\n  PAUSE,\n  INPUT,\n  FOR,\n  NEXT,\n  PLOT,\n  END,\n  IF,\n  GOSUB,\n  RETURN,\n  ARRAY,\n  CLS,\n  CLT,\n  CLC,\n  Variable,\n};\n","function exprToJS(expr) {\n  let jsExpr = '';\n\n  while (expr.length) {\n    const t = expr.shift();\n\n    if (t.type === 'variable') {\n      jsExpr += '__pgb.get(\"' + t.lexeme + '\")';\n      continue;\n    }\n\n    if (t.type === 'function') {\n      jsExpr += '__pgb.fun(\"' + t.lexeme + '\")';\n      continue;\n    }\n\n    if (t.type === 'constant') {\n      jsExpr += '__pgb.getConst(\"' + t.lexeme + '\")';\n      continue;\n    }\n\n    if (t.type === 'logic') {\n      if (t.lexeme === 'AND') {\n        jsExpr += '&&';\n      } else if (t.lexeme === 'OR') {\n        jsExpr += '||';\n      }\n\n      continue;\n    }\n\n    if (t.type === 'operation') {\n      if (t.lexeme === '<>') {\n        jsExpr += '!=';\n        continue\n      }\n\n      if (t.lexeme === '=') {\n        jsExpr += '==';\n        continue;\n      }\n    }\n\n    jsExpr += t.lexeme;\n  }\n\n  return jsExpr;\n}\n\nmodule.exports = exprToJS;","const Tokenizer = require('./tokenizer');\nconst {\n  PRINT,\n  LET,\n  REM,\n  PAUSE,\n  INPUT,\n  FOR,\n  NEXT,\n  GOTO,\n  END,\n  IF,\n  GOSUB,\n  RETURN,\n  ARRAY,\n  PLOT,\n  CLS,\n  CLC,\n  CLT,\n  Variable\n} = require('./nodes');\nconst exprToJS = require('./expr');\n\nclass Parser {\n  static parseLine(line) {\n    const t = new Tokenizer(line, { debug: true });\n    t.tokenize();\n\n    const lineno = getLineNo(t.next());\n\n    const p = new Parser(t, lineno);\n\n    return p.parse();\n  }\n\n  constructor(tokenizer, lineno) {\n    this.tokenizer = tokenizer;\n    this.lineno = lineno;\n  }\n\n  parse() {\n    const top = this.tokenizer.next();\n    assertType(top, 'keyword');\n\n    switch (top.lexeme) {\n      case 'PRINT':\n        return new PRINT(this.lineno, this.expectExpr(), this.acceptLineMod());\n\n      case 'LET': {\n        const variable = this.expectVariable();\n        this.expectOperation('=');\n        return new LET(this.lineno, variable, this.expectExpr());\n      }\n\n      case 'REM':\n        return new REM(this.lineno, this.expectComment());\n\n      case 'PAUSE':\n        return new PAUSE(this.lineno, this.expectExpr());\n\n      case 'INPUT': {\n        const expr = this.expectExpr();\n        this.expectLineMod();\n        return new INPUT(this.lineno, expr, this.expectVariable());\n      }\n\n      case 'FOR': {\n        const variable = this.expectVariable();\n        this.expectOperation('=');\n        const frm = this.expectExpr();\n        this.expectKeyword('TO');\n        const to = this.expectExpr();\n        const step = this.acceptKeyword('STEP') ? this.expectExpr() : null;\n\n        return new FOR(this.lineno, variable, frm, to, step);\n      }\n\n      case 'NEXT':\n        return new NEXT(this.lineno, this.expectVariable());\n\n      case 'GOTO':\n        return new GOTO(this.lineno, this.expectExpr());\n\n      case 'END':\n        return new END(this.lineno);\n\n      case 'IF':\n        const cond = this.expectExpr();\n        this.expectKeyword('THEN');\n\n        let then;\n        // Shortcut: number is interpreted as goto statement.\n        if (this.tokenizer.peek().type === 'number') {\n          then = new GOTO(this.lineno, this.expectExpr());\n        } else {\n          then = this.parse();\n        }\n\n        let elze = null;\n        if (this.acceptKeyword('else')) {\n          if (this.tokenizer.peek().type === 'number') {\n            elze = new GOTO(this.lineno, this.expectExpr());\n          } else {\n            elze = this.parse();\n          }\n        }\n\n        return new IF(this.lineno, cond, then, elze);\n\n      case 'GOSUB':\n        return new GOSUB(this.lineno, this.expectExpr());\n\n      case 'RETURN':\n        return new RETURN(this.lineno);\n\n      case 'ARRAY':\n        return new ARRAY(this.lineno, this.expectVariable());\n\n      case 'PLOT':\n        const x = this.expectExpr(true);\n        this.expectOperation(',');\n        const y = this.expectExpr(true);\n        this.expectOperation(',');\n        const color = this.expectExpr(true);\n\n        return new PLOT(this.lineno, x, y, color);\n\n      case 'CLS':\n        return new CLS(this.lineno);\n      case 'CLC':\n        return new CLC(this.lineno);\n      case 'CLT':\n        return new CLT(this.lineno);\n    }\n\n    throw new Error(`Unexpected token ${top.lexeme}`);\n  }\n\n  acceptKeyword(keyword) {\n    if (this.tokenizer.peek().type === 'keyword') {\n      return this.tokenizer.next();\n    }\n\n    return null;\n  }\n\n  expectKeyword(keyword) {\n    const t = this.acceptKeyword(keyword);\n    if (t == null) {\n      throw new Error(`Expected ${keyword} but got ${this.tokenizer.peek().lexeme}`);\n    }\n\n    return t.lexeme;\n  }\n\n  expectComment() {\n    const t = this.tokenizer.next();\n\n    if (t.type === 'comment') {\n      assertType(this.tokenizer.next(), 'eof');\n      return t.lexeme;\n    }\n\n    assertType(t, 'eof');\n    return '';\n  }\n\n  expectOperation(op) {\n    const t = this.tokenizer.next();\n    assertType(t, 'operation');\n    if (t.lexeme !== op) {\n      throw new Error('Expected operation ' + op)\n    }\n    return t.lexeme;\n  }\n\n  expectVariable() {\n    const t = this.tokenizer.next();\n    assertType(t, 'variable');\n    return new Variable(this.lineno, t.lexeme, this.acceptSubscript());\n  }\n\n  expectExpr(stopOnComma = false) {\n    const expr = [];\n    let brackets = 0;\n    while (this.tokenizer.peek() != Tokenizer.eof) {\n      if (stopOnComma && this.tokenizer.peek().lexeme === ',') {\n        break;\n      }\n\n      if (!Tokenizer.expressionTypes.includes(this.tokenizer.peek().type)) {\n        break;\n      }\n\n      const t = this.tokenizer.peek();\n\n      // We might be in a subscript or function call and if we see an\n      // extra paren it's not ours to eat.\n      if (brackets === 0 && (t.lexeme === ']' || t.lexeme === ')')) {\n        break;\n      }\n\n      this.tokenizer.next();\n\n      if (t.lexeme === '[' || t.lexeme === '(') {\n        brackets++;\n      }\n\n      if (t.lexeme === ']' || t.lexeme === ']') {\n        brackets--;\n      }\n\n      expr.push(t);\n    }\n\n    if (expr.length === 0) {\n      throw new Error('Expected expression');\n    }\n\n    return exprToJS(expr);\n  }\n\n  expectLineMod() {\n    if (!this.acceptLineMod()) {\n      throw new Error('Expected ;');\n    }\n\n    return true;\n  }\n\n  acceptLineMod() {\n    if (this.tokenizer.peek().type === 'linemod') {\n      this.tokenizer.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  acceptSubscript() {\n    if (this.tokenizer.peek().lexeme !== '[') return null;\n\n    assertType(this.tokenizer.next(), 'operation', '[');\n\n    const expr = this.expectExpr();\n\n    assertType(this.tokenizer.next(), 'operation', ']');\n\n    return expr;\n  }\n}\n\nfunction assertType(token, expected, value = null) {\n  if (token.type !== expected) {\n    throw new Error(`Expect token of type ${expected} but got ${token.type}`);\n  }\n\n  if (value != null && token.lexeme !== value) {\n    throw new Error(`Expected token value to be ${value} but got ${token.lexeme}`);\n  }\n}\n\nfunction getLineNo(token) {\n  assertType(token, 'lineno');\n\n  if (typeof token.lexeme !== 'number') {\n    throw new Error('lineno should be a number');\n  }\n\n  return token.lexeme;\n}\n\nmodule.exports = Parser;","const Context = require('context-eval');\nconst Parser = require('./parser');\nconst Functions = require('./functions');\n\nclass Basic {\n  constructor({ console, debugLevel, display, constants = {\n    PI: Math.PI,\n    LEVEL: 1,\n  } }) {\n    this.debugLevel = debugLevel;\n    this.console = console;\n    this.context = new Context({\n      __pgb: this,\n    });\n    this.variables = {};\n    this.lineno = -1;\n    this.program = [];\n    this.loops = {};\n    this.stack = [];\n    this.jumped = false;\n    this.display = display;\n    this.constants = constants;\n  }\n\n  debug(str, level = 1) {\n    if (this.debugLevel >= level) {\n      console.log(`Debug ${this.lineno}:`, str);\n    }\n  }\n\n  run(program) {\n    const seen = {};\n    this.program = program.split('\\n')\n      .filter(l => l.trim() !== '')\n      .map((l) => Parser.parseLine(l))\n      .sort((a, b) => a.lineno - b.lineno);\n\n    this.program.forEach(({ lineno }) => {\n      if (seen[lineno]) {\n        throw new Error(`Line with number ${lineno} repeated`);\n      }\n      seen[lineno] = true;\n    });\n\n\n    if (!this.program.length) return this.end();\n\n    this.lineno = this.program[0].lineno;\n\n    this.execute();\n  }\n\n  execute() {\n    while (true) {\n      this.step();\n\n      if (this.ended) return;\n\n      if (!this.jumped) {\n        const next = this.getNextLine();\n\n        if (!next) {\n          this.end();\n          return;\n        }\n\n        this.lineno = next.lineno;\n      } else {\n        this.jumped = false;\n      }\n\n      if (this.delay) {\n        const delay = this.delay;\n        this.delay = null;\n        return setTimeout(() => {\n          this.execute();\n        }, delay)\n      }\n\n      if (this.halted) {\n        return;\n      }\n    }\n  }\n\n  getCurLine() {\n    return this.program.find(({ lineno }) => lineno === this.lineno);\n  }\n\n  getNextLine() {\n    return this.program[this.program.indexOf(this.getCurLine()) + 1];\n  }\n\n  step() {\n    const node = this.getCurLine();\n\n    if (!node) {\n      throw new Error(`Cannot find line with number ${this.lineno}`);\n    }\n\n    this.debug('step', 1);\n    this.debug(node.toJSON(), 2);\n\n    node.run(this);\n  }\n\n  end() {\n    this.ended = true;\n    this.debug('program ended');\n  }\n\n  evaluate(code) {\n    try {\n      return this.context.evaluate(code);\n    } catch (e) {\n      console.error('Error evaluating code:', code);\n      throw e;\n    }\n  }\n\n  set(vari, value) {\n    this.variables[vari] = value;\n  }\n\n  setArray(vari, sub, value) {\n    this.variables[vari][sub] = value;\n  }\n\n  array(name) {\n    this.variables[name] = {};\n  }\n\n  fun(name) {\n    if (!Functions[name]) {\n      throw new Error(`Function ${name} does not exist`);\n    }\n\n    // External functions\n    switch (name.toLowerCase()) {\n      case 'color':\n        return this.color.bind(this);\n      case 'getchar':\n        return this.getChar.bind(this);\n    }\n\n    // Internal utils\n    return Functions[name];\n  }\n\n  get(vari) {\n    return this.variables[vari] || 0;\n  }\n\n  getConst(constant) {\n    if (this.constants.hasOwnProperty(constant)) {\n      return this.constants[constant]\n    }\n    throw new Error(`Constant ${constant} undefined`);\n  }\n\n  pause(millis) {\n    this.debug(`pause ${millis}`)\n    this.delay = millis;\n  }\n\n  goto(lineno) {\n    this.debug(`goto ${lineno}`)\n    this.lineno = lineno;\n    this.jumped = true;\n  }\n\n  loopStart({ variable, value, increment, max }) {\n    this.debug(`marking loop ${variable}`)\n\n    this.set(variable, value);\n    const next = this.getNextLine();\n    if (!next) return this.end();\n\n    this.loops[variable] = {\n      variable,\n      value,\n      increment,\n      max,\n      lineno: next.lineno,\n    };\n  }\n\n  loopJump(name) {\n    this.debug(`jumping to loop ${name}`);\n\n    const loop = this.loops[name];\n    loop.value += loop.increment;\n    this.set(loop.variable, loop.value);\n\n    if (loop.value >= loop.max) return;\n\n    this.goto(loop.lineno);\n  }\n\n  gosub(lineno) {\n    const next = this.getNextLine();\n    if (next) {\n      this.stack.push(next.lineno);\n    } else {\n      this.stack.push(this.lineno + 1);\n    }\n    this.goto(lineno);\n  }\n\n  return() {\n    if (this.stack.length === 0) {\n      throw new Error('No function calls to return from');\n    }\n    const lineno = this.stack.pop();\n    this.goto(lineno);\n  }\n\n  assertDisplay() {\n    if (!this.display) {\n      throw new Error('No display found');\n    }\n  }\n\n  plot(x, y, color) {\n    this.assertDisplay();\n    this.display.plot(x, y, color);\n  }\n\n  color(x, y) {\n    this.assertDisplay();\n    return this.display.color(x, y);\n  }\n\n  clearAll() {\n    this.clearConsole();\n    this.clearGraphics();\n  }\n\n  print(s) {\n    this.console.write(s.toString());\n  }\n\n  clearConsole() {\n    this.console.clear();\n  }\n\n  clearGraphics() {\n    this.assertDisplay();\n    this.display.clear();\n  }\n\n  getChar() {\n    this.assertDisplay();\n    return this.display.getChar() || '';\n  }\n\n  input(callback) {\n    this.console.input(callback);\n  }\n\n  halt() {\n    this.halted = true;\n  }\n}\n\nmodule.exports = Basic;\n"]}